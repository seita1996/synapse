---
tags:
  - moc
enableToc: "true"
draft: "false"
permalink: moc/functional-programming
---
## 1. [[FPの基本概念と歴史 MOC]]
   - **FPの定義と目的**
      - [[関数型プログラミングとは (計算を数学的な関数の評価として扱う)]]
      - [[FPの主な目標 (副作用の排除、状態の不変性、宣言的な記述)]]
      - [[FPの利点 (簡潔性、予測可能性、テスト容易性、並行処理との親和性)]]
   - **FPの歴史的背景**
      - **[[ラムダ計算 (Lambda Calculus) - アロンゾ・チャーチ]]** (FPの理論的基礎)
      - **[[LISP言語とその影響]]** (初期の関数型言語、マクロ、S式)
      - **[[ML言語ファミリー (Standard ML, OCaml, F#)]]** (静的型付け、型推論、パターンマッチ)
      - **[[Haskell言語と純粋関数型プログラミング]]** (遅延評価、モナド、型クラス)
      - [[Erlangとアクターモデル、並行処理]]
      - [[Scheme, Clojure, Scalaなどの進化と特徴]]
   - **他のプログラミングパラダイムとの比較**
      - [[命令型プログラミングと宣言型プログラミング]]
      - [[手続き型プログラミングと関数型プログラミングの違い]]
      - [[オブジェクト指向プログラミング (OOP) と関数型プログラミング (FP) の比較と融合]]
         - [[状態管理の違い (OOPの可変状態 vs FPの不変状態)]]
         - [[ポリモーフィズムの実現方法の違い (OOPの継承/インターフェース vs FPの型クラス/高階関数)]]
         - [[関数型オブジェクト (Functional Objects)]]
   - **式 (Expression) と文 (Statement)**
      - [[FPにおける式の重視 (すべての式が値を返す)]]
      - [[命令型における文の役割との対比]]

## 2. [[FPのコア原則 MOC]]
   - **[[純粋関数 (Pure Functions) MOC]]**
      - [[純粋関数の定義 (同じ入力に対して常に同じ出力を返し、副作用を持たない)]]
      - [[純粋関数の性質 (決定性、副作用なし)]]
      - [[純粋関数の利点 (テスト容易性、予測可能性、デバッグの容易さ、並行処理の安全性)]]
      - [[純粋関数の例と非純粋関数の例]]
   - **[[副作用 (Side Effects) の管理 MOC]]**
      - [[副作用とは何か (状態の変更、I/O操作、グローバル変数の変更など)]]
      - [[なぜ副作用を避けるのか (複雑性の増大、予測不可能性)]]
      - [[FPにおける副作用の分離と制御 (I/Oモナドなど - 導入)]]
   - **[[不変性 (Immutability) MOC]]**
      - [[不変性の定義 (一度作成されたデータ構造は変更されない)]]
      - [[不変なデータ構造の利点 (単純さ、スレッドセーフティ、変更追跡の容易さ、デバッグ)]]
      - [[不変性を実現するテクニック (コピーオンライト - Copy-on-Write)]]
      - [[永続データ構造 (Persistent Data Structures) の概念]] (効率的な不変データ構造)
      - [[可変性 (Mutability) との比較]]
   - **[[参照透過性 (Referential Transparency) MOC]]**
      - [[参照透過性の定義 (式をその評価結果で置き換えてもプログラムの動作が変わらない)]]
      - [[参照透過性と純粋関数の関係]]
      - [[参照透過性の利点 (コードの推論の容易さ、最適化)]]
   - **[[関数は第一級オブジェクト (First-Class Functions) MOC]]**
      - [[第一級オブジェクトの定義 (変数への代入、引数としての受け渡し、戻り値としての返しが可能)]]
      - [[無名関数 (Anonymous Functions) / ラムダ式 (Lambda Expressions)]]
      - [[関数をデータとして扱う例]]
   - **[[高階関数 (Higher-Order Functions - HOFs) MOC]]**
      - [[高階関数の定義 (関数を引数に取るか、関数を返す関数)]]
      - [[高階関数の強力さと柔軟性]]

## 3. [[主要な関数型テクニックと概念 MOC]]
   - **再帰 (Recursion)**
      - [[再帰の基本 (ベースケースと再帰ステップ)]]
      - [[ループ構造の代替としての再帰]]
      - **[[末尾再帰 (Tail Recursion)]]**
         - [[末尾再帰の定義とスタックオーバーフローの回避]]
         - **[[末尾呼び出し最適化 (TCO - Tail Call Optimization)]]**
      - [[再帰を用いたデータ構造の処理 (リスト、ツリーなど)]]
      - [[再帰パターンの例 (線形再帰、木構造再帰)]]
      - [[(オプション) 不動点コンビネータ (Fixed-point combinator - Yコンビネータ)]] (理論的背景)
   - **高階関数の具体的な活用 (HOFs in Practice)**
      - **[[map関数 (または fmap)]]** (コレクションの各要素に関数を適用)
      - **[[filter関数]]** (コレクションから条件を満たす要素を抽出)
      - **[[reduce関数 / fold関数 (foldl, foldr)]]** (コレクションを単一の値に畳み込む)
      - [[zip関数とunzip関数]]
      - [[(オプション) scan関数]]
   - **カリー化 (Currying)**
      - [[カリー化の定義 (複数の引数を取る関数を、単一の引数を取る関数の連続に変換)]]
      - [[カリー化の利点 (部分適用、関数の再利用性向上)]]
      - [[カリー化の実装例]]
   - **部分適用 (Partial Application)**
      - [[部分適用の定義 (関数の引数の一部を固定して新しい関数を作成)]]
      - [[部分適用とカリー化の違い]]
      - [[部分適用の利用例]]
   - **関数合成 (Function Composition)**
      - [[関数合成の定義 (複数の関数を組み合わせて新しい関数を作成)]] (例: `f . g`)
      - [[関数合成の利点 (宣言的なコード、パイプライン処理)]]
      - [[ポイントフリースタイル (Point-Free Style / Tacit Programming)]]
         - [[ポイントフリースタイルの定義と利点・欠点]]
   - **遅延評価 (Lazy Evaluation / Non-strict Evaluation)**
      - [[遅延評価の定義 (式が必要になるまで評価を遅らせる)]]
      - [[遅延評価の利点 (無限データ構造の扱いや不要な計算の回避による性能向上)]]
      - [[サンク (Thunk) の概念]]
      - [[正格評価 (Strict Evaluation) との比較]]
      - [[Haskellにおける遅延評価]]
      - [[(オプション) 遅延データ構造 (Lazy Data Structures)]] (例: 遅延リスト/ストリーム)
   - **クロージャ (Closure)**
      - [[クロージャの定義 (関数とその関数が定義された語彙的環境の組み合わせ)]]
      - [[自由変数 (Free Variable) と束縛変数 (Bound Variable)]]
      - [[クロージャの利用例 (状態の保持、コールバック関数)]]

## 4. [[型システムと関数型プログラミング MOC]]
   - **静的型付けと動的型付け**
      - [[関数型言語における型システムの役割 (安全性、表現力)]]
   - **型推論 (Type Inference)**
      - [[型推論の仕組み (例: Hindley-Milner型推論アルゴリズム)]]
      - [[型推論の利点 (コードの簡潔さと型安全性の両立)]]
   - **代数的データ型 (ADT - Algebraic Data Types)**
      - **[[直積型 (Product Types)]]** (タプル、レコード、構造体など)
      - **[[直和型 (Sum Types / Tagged Unions / Variants)]]** (複数の可能性のうちの一つを表す型)
         - [[Maybe型 / Option型 (値が存在しない可能性の表現)]]
         - [[Either型 / Result型 (成功またはエラーの表現)]]
      - [[代数的データ型とパターンマッチの組み合わせ]]
   - **パターンマッチ (Pattern Matching)**
      - [[パターンマッチの仕組み (データ構造の形状に基づいて処理を分岐)]]
      - [[パターンマッチの利用例 (リスト処理、木構造処理、直和型の分解)]]
      - [[網羅性チェック (Exhaustiveness Checking) と冗長性チェック]]
      - [[ガード (Guard) を伴うパターンマッチ]]
   - **パラメータ多相 (Parametric Polymorphism) / ジェネリクス (Generics)**
      - [[型に依存しない関数やデータ構造の定義]]
   - **アドホック多相 (Ad-hoc Polymorphism) / オーバーロード (Overloading)**
      - [[型クラス (Type Classes) - Haskell]] (アドホック多相の実現方法)
         - [[型クラスの定義とインスタンス]]
         - [[代表的な型クラス (Eq, Ord, Show, Functor, Monadなど)]]
   - **高カインド型 (Higher-Kinded Types - HKT)** (高度なトピック)
   - **[[(オプション) 依存型 (Dependent Types)]]** (値に依存する型 - より強力な静的検証)
   - **[[(オプション) 線形型 (Linear Types)]]** (リソースを一度だけ使用することを保証する型)

## 5. [[関数型プログラミングにおけるデータ構造 MOC]]
   - **不変データ構造の重要性 (再掲)**
   - **基本的な不変データ構造**
      - **[[不変リスト (Immutable List)]]** (Consセル、Nil)
         - [[リスト操作 (head, tail, cons, append, map, filter, fold)]]
      - **[[不変木構造 (Immutable Tree)]]** (二分木、汎用木など)
         - [[木構造操作 (探索、挿入、削除 - 新しい木を返す)]]
      - **[[不変マップ (Immutable Map / Dictionary)]]**
      - **[[不変セット (Immutable Set)]]**
   - **永続データ構造 (Persistent Data Structures)**
      - [[永続データ構造の定義 (更新操作後も以前のバージョンが保持される)]]
      - [[部分永続性、完全永続性、融合永続性]]
      - [[永続データ構造の効率と実現方法 (例: パス共有)]]
      - [[代表的な永続データ構造 (永続スタック、永続キュー、永続平衡木など)]]
   - **[[(オプション) ストリーム (Streams) / 遅延リスト (Lazy Lists)]]** (無限データ構造の表現)

## 6. [[モナドと関数型エラー処理・副作用管理 MOC]] (導入～中級)
   - **モナドの導入**
      - [[なぜモナドが必要か (副作用の分離、文脈を持つ計算の連鎖)]]
      - [[モナドの直感的説明 (箱、計算のコンテナ、プログラム可能なセミコロン)]]
      - [[モナド則 (Monad Laws - 左単位元則、右単位元則、結合則)]] (概要)
   - **具体的なモナドの例**
      - **[[Maybeモナド / Optionモナド]]**
         - [[値が存在しない可能性の安全な取り扱い (NullPointerExceptionの回避)]]
         - [[Maybe/Option型の定義 (Some/Just と None/Nothing)]]
         - [[Maybe/Optionモナドの操作 (return/unit, bind/flatMap, map/fmap)]]
      - **[[Eitherモナド / Resultモナド]]**
         - [[成功またはエラーを表す計算の表現]]
         - [[Either/Result型の定義 (Left/Err と Right/Ok)]]
         - [[Either/Resultモナドの操作]]
      - **[[IOモナド]]**
         - [[入出力操作などの副作用を純粋関数型プログラミングに統合する方法]]
         - [[IOアクションとしての副作用の表現]]
         - [[IOモナドの操作 (return, bind)]]
      - **[[(オプション) Listモナド]]** (非決定性計算)
      - **[[(オプション) Stateモナド]]** (状態変化の管理)
      - **[[(オプション) Readerモナド]]** (環境依存計算)
      - **[[(オプション) Writerモナド]]** (ログ出力などの追加情報)
   - **ファンクタ (Functor) とアプリカティブファンクタ (Applicative Functor)**
      - **[[ファンクタとは (map/fmap操作をサポートする型コンストラクタ)]]**
         - [[ファンクタ則 (同一性、合成)]]
      - **[[アプリカティブファンクタとは (関数をコンテキストに適用する)]]**
         - [[`pure`/`return` と `<*>`/`ap` 操作]]
         - [[アプリカティブ則]]
         - [[ファンクタとアプリカティブファンクタ、モナドの関係]]
   - **[[(オプション) モナドトランスフォーマー (Monad Transformers)]]** (モナドの組み合わせ)

## 7. [[関数型プログラミングのパターンとイディオム MOC]]
   - **[[関数合成 (Function Composition) のパターン]]** (再掲、より実践的に)
   - **[[ポイントフリースタイル (Point-Free Style) の活用例]]** (再掲)
   - **[[パイプライン処理 (Pipelining / Threading Macro)]]** (例: `|>` in F#, `->` in Clojure)
   - **[[メモ化 (Memoization)]]** (純粋関数の結果をキャッシュして高速化)
   - **[[継続 (Continuation) と継続渡しスタイル (CPS - Continuation-Passing Style)]]** (高度な制御フロー)
   - **[[代数的データ型とパターンマッチを活用した設計パターン]]**
   - **[[MonoidとSemigroup]]** (結合可能なデータ構造と操作)
   - **[[(オプション) レンズ (Lenses)]]** (不変データ構造の特定部分へのアクセスと更新を関数的に行う)

## 8. [[並行処理・並列処理と関数型プログラミング MOC]]
   - **[[なぜFPは並行処理に適しているのか (不変性、副作用の排除)]]**
   - **[[データ並列性 (Data Parallelism) とタスク並列性 (Task Parallelism)]]**
   - **FPにおける並行処理のモデル**
      - **[[アクターモデル (Actor Model)]]** (Erlang/OTP, Akka)
         - [[アクターの概念 (状態、振る舞い、メールボックス)]]
         - [[メッセージパッシングによる非同期通信]]
      - **[[ソフトウェアトランザクションメモリ (STM - Software Transactional Memory)]]** (Clojure, Haskell)
         - [[アトミックなメモリ操作の実現]]
      - **[[Futures / Promises]]** (非同期処理の結果の表現)
      - **[[並列コレクション操作 (Parallel Collections)]]** (例: Java Streams APIの並列ストリーム, Scalaの並列コレクション)
   - **[[イミュータブルデータ構造とロックフリープログラミング]]**

## 9. [[関数型プログラミングの利点と欠点 (再評価) MOC]]
   - **利点 (まとめ)**
      - [[コードの簡潔性と可読性 (宣言的スタイル)]]
      - [[テスト容易性とデバッグの容易さ (純粋関数、不変性)]]
      - [[並行処理・並列処理の安全性と容易さ]]
      - [[高い抽象化レベルと再利用性 (高階関数、関数合成)]]
      - [[数学的基盤による堅牢性]]
   - **欠点と課題**
      - [[学習コストの高さ (新しい思考様式)]]
      - [[パフォーマンスの問題 (不変データ構造のコピーコスト、遅延評価のオーバーヘッド - ただし最適化も進んでいる)]]
      - [[特定の種類の問題 (例: GUIプログラミング、状態変化が中心の問題) での表現の難しさ]] (ただし克服する試みも多い)
      - [[既存の命令型ライブラリとの連携]]
      - [[スタックオーバーフロー (末尾再帰最適化がない場合)]]

## 10. [[主要プログラミング言語における関数型プログラミング MOC]]
   - **純粋関数型言語**
      - **[[HaskellにおけるFP]]** (遅延評価、型クラス、モナド、純粋性)
   - **関数型が強いマルチパラダイム言語**
      - **[[LISPファミリー (Scheme, Common LISP, Clojure) におけるFP]]** (S式、マクロ、REPL、Clojureの不変性とSTM)
      - **[[MLファミリー (SML, OCaml, F#) におけるFP]]** (強力な型システム、型推論、パターンマッチ、命令型機能とのバランス)
      - **[[ScalaにおけるFP]]** (オブジェクト指向との融合、不変コレクション、ケースクラス、Akka)
      - **[[Erlang/ElixirにおけるFP]]** (アクターモデル、OTP、耐障害性)
   - **命令型言語における関数型機能の取り込み**
      - **[[JavaScriptにおけるFP]]** (第一級関数、クロージャ、アロー関数、map/filter/reduce、ライブラリ(Lodash, Ramda))
      - **[[PythonにおけるFP]]** (ラムダ式、リスト内包表記、ジェネレータ、itertools, functoolsモジュール)
      - **[[JavaにおけるFP (Java 8以降)]]** (ラムダ式、Stream API、Optionalクラス、関数型インターフェース)
      - **[[C#におけるFP]]** (LINQ、ラムダ式、拡張メソッド、タプル、パターンマッチ)
      - **[[C++におけるFP (C++11以降)]]** (ラムダ式、`<functional>`ヘッダ、`<algorithm>`ヘッダ)

## 11. [[関数型プログラミングの数学的基礎 MOC]] (概要)
   - **[[ラムダ計算 (Lambda Calculus) の概要]]**
      - [[ラムダ抽象、ラムダ適用、変数]]
      - [[β簡約、α変換、η変換]]
      - [[ラムダ計算とチューリング完全性]]
   - **[[圏論 (Category Theory) とFPの関係]]** (概要)
      - [[圏 (Category)、対象 (Object)、射 (Morphism)]]
      - [[ファンクタ (Functor) の圏論的解釈]]
      - [[モナド (Monad) の圏論的解釈 (Kleisli Tripleなど)]]
      - [[(オプション) 自然変換 (Natural Transformation)]]
   - **[[型理論 (Type Theory)]]** (概要)
      - [[カリー＝ハワード同型対応 (Curry-Howard Correspondence)]] (型と論理命題、プログラムと証明の対応)

## 12. [[(オプション) 関数型リアクティブプログラミング (FRP - Functional Reactive Programming) MOC]]
   - [[FRPの概念 (時間とともに変化する値 (シグナル/イベントストリーム) を扱う関数型の手法)]]
   - [[イベントストリームとビヘイビア]]
   - [[FRPライブラリの例 (RxJS, Bacon.jsなど)]]
   - [[FRPの応用 (UIプログラミング、非同期処理)]]