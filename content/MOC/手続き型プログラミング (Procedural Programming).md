---
tags:
  - moc
enableToc: "true"
draft: "false"
permalink: moc/procedural-programming
---
## 1. [[手続き型プログラミングの基本概念と歴史 MOC]]
   - **手続き型プログラミングの定義と目標**
      - [[手続き型プログラミングとは (一連の手続きや関数の呼び出しとしてプログラムを構成)]]
      - [[手続き型プログラミングの主な目標 (問題を小さなタスクに分割、コードの構造化)]]
      - [[命令型プログラミング (Imperative Programming) との関係]] (手続き型は命令型の一分野)
   - **手続き型プログラミングの歴史的背景**
      - [[機械語とアセンブリ言語からの進化]]
      - [[初期の高水準言語と手続き型]]
         - [[FORTRANと科学技術計算]]
         - [[COBOLと事務処理]]
         - [[ALGOLとアルゴリズム記述、構造化の萌芽]]
         - [[Pascalと教育、構造化プログラミング]]
         - [[C言語とシステムプログラミング、UNIX]]
         - [[BASICの初期のバージョン]]
      - [[構造化プログラミングの登場と影響]]
   - **他のプログラミングパラダイムとの比較**
      - [[オブジェクト指向プログラミング (OOP) と手続き型プログラミングの違い]] (データと手続きの分離 vs. カプセル化)
      - [[関数型プログラミング (FP) と手続き型プログラミングの違い]] (副作用、状態変更の扱い)
      - [[手続き型プログラミングの現代における位置づけと影響]] (多くの言語の基礎)

## 2. [[手続き (Procedure) / 関数 (Function) / サブルーチン (Subroutine) MOC]]
   - **定義と目的**
      - [[手続きとは (特定のタスクを実行する一連の命令のまとまり)]]
      - [[関数、サブルーチン、プロシージャ、メソッドの用語の違いと共通点]]
      - [[コードの再利用性の向上]]
      - [[プログラムの可読性と保守性の向上]]
      - [[モジュール化の基本単位]]
   - **手続きの呼び出しと復帰 (Procedure Call and Return)**
      - [[呼び出し側 (Caller) と被呼び出し側 (Callee)]]
      - [[プログラムカウンタの制御移譲]]
      - **[[スタックフレーム (Stack Frame) / アクティベーションレコード (Activation Record)]]**
         - [[スタックフレームの構成要素 (引数、ローカル変数、戻りアドレス、保存レジスタ)]]
         - [[コールスタック (Call Stack) の役割]]
   - **引数 (Argument) と仮引数 (Parameter)**
      - [[仮引数の宣言と実引数の受け渡し]]
      - **引数渡し方式 (Parameter Passing Mechanisms)**
         - **[[値渡し (Pass-by-Value)]]**
            - [[値渡しの仕組みと副作用のなさ]]
         - **[[参照渡し (Pass-by-Reference)]]**
            - [[参照渡しの仕組み (エイリアス) と副作用の可能性]]
            - [[ポインタ渡し (Pass-by-Pointer) との関係]] (C言語など)
         - **[[(オプション) 結果返し (Pass-by-Result)]]**
         - **[[(オプション) 値結果返し (Pass-by-Value-Result / Copy-Restore)]]**
         - **[[(オプション) 名前渡し (Pass-by-Name)]]** (ALGOLなど、遅延評価に類似)
      - [[可変長引数リスト (Variable Number of Arguments)]] (C言語の `va_list` など)
   - **戻り値 (Return Value)**
      - [[手続きからの結果の返し方]]
      - [[`void` / `procedure` (戻り値なし) と `function` (戻り値あり)]]
      - [[複数の戻り値の扱い方 (構造体、ポインタ、タプルなど)]]
   - **変数のスコープと生存期間 (Scope and Lifetime of Variables)**
      - **[[ローカル変数 (Local Variables)]]**
         - [[ローカル変数のスコープ (手続き内)]]
         - [[ローカル変数の生存期間 (手続き実行中)]]
         - [[自動変数 (Automatic Variables)]] (スタック上に確保)
      - **[[グローバル変数 (Global Variables)]]**
         - [[グローバル変数のスコープ (プログラム全体)]]
         - [[グローバル変数の生存期間 (プログラム実行中)]]
         - [[グローバル変数の使用に関する注意点 (副作用、可読性低下)]]
      - **[[静的ローカル変数 (Static Local Variables)]]** (C言語など)
         - [[静的ローカル変数のスコープと生存期間]]
   - **副作用 (Side Effects) のある手続き**
      - [[手続きが状態を変更する場合 (グローバル変数、参照渡しされた引数、I/O操作)]]
      - [[副作用の管理と注意点]]
   - **再帰手続き (Recursive Procedures)**
      - [[再帰の定義と動作原理]]
      - [[ベースケースと再帰ステップ]]
      - [[再帰とスタックオーバーフロー]]
      - [[末尾再帰 (Tail Recursion) とその最適化の可能性]] (手続き型言語では限定的)

## 3. [[モジュール性 (Modularity) とプログラム構造 MOC]]
   - **モジュール化の概念**
      - [[プログラムを独立したモジュールに分割する意義]]
      - [[モジュールの独立性と凝集度 (Cohesion)、結合度 (Coupling)]]
   - **ソースファイルの分割とリンク**
      - [[ヘッダファイルと実装ファイル (C言語など)]]
      - [[前方宣言 (Forward Declaration)]]
      - **[[個別コンパイル (Separate Compilation)]]**
      - **[[リンカ (Linker) とライブラリ (Library)]]**
         - [[静的ライブラリ (Static Library)]]
         - [[動的ライブラリ (Dynamic Library / Shared Library)]]
   - **名前空間 (Namespace) とスコープ解決** (限定的、C言語では主にファイルスコープ)
      - `[[static` キーワードによる内部リンケージ (C言語)]]
   - **情報隠蔽 (Information Hiding) の実現** (手続き型における限定的な方法)
      - [[モジュール内部の詳細を隠蔽し、インターフェースのみを公開する考え方]]
      - [[C言語における `static` 関数や `static` グローバル変数]]
      - [[抽象データ型 (ADT - Abstract Data Type) の手続き型での実現の試み]] (構造体とそれを操作する関数のセット)

## 4. [[制御構造 (Control Structures) MOC]]
   - **[[構造化プログラミング (Structured Programming) の原則]]**
      - [[順次実行 (Sequence)]]
      - [[選択 (Selection / Conditional)]]
      - [[反復 (Iteration / Loop)]]
      - [[単一入口・単一出口の原則]]
   - **順次実行**
      - [[プログラムの命令が記述された順に実行される基本原則]]
   - **選択 / 条件分岐構造**
      - **`[[if` 文]]**
         - `[[if-then` 構造]]
         - `[[if-then-else` 構造]]
         - `[[else if` / `elif` による多分岐]]
         - [[ネストされた `if` 文]]
      - **`[[switch` / `case` 文 / `select` 文]]**
         - [[多分岐処理の効率的な記述]]
         - `[[case` ラベルと `default` / `otherwise` 句]]
         - `[[break` 文の役割 (C言語など)]] (フォールスルー)
   - **反復 / ループ構造**
      - **[[カウンタ制御ループ (`for` ループ)]]**
         - [[初期化、条件式、更新式の構成要素]]
         - [[`for` ループの様々な形式 (Pascal, C, Pythonなど)]]
      - **[[条件制御ループ (前判定 - `while` ループ)]]**
         - [[ループ実行前に条件を評価]]
      - **[[条件制御ループ (後判定 - `do-while` / `repeat-until` ループ)]]**
         - [[ループ実行後に条件を評価 (最低1回は実行)]]
      - **[[ループ制御文]]**
         - `[[break` 文 (ループからの脱出)]]
         - `[[continue` 文 (ループの次の反復へ)]]
      - [[無限ループ (Infinite Loop) とその対処]]
      - [[ネストされたループ]]
   - **`[[goto` 文]]**
      - [[`goto` 文の機能 (無条件ジャンプ)]]
      - **[[`goto` 文の弊害と構造化プログラミングにおける忌避]]**
         - [[可読性の低下 (スパゲッティコード)]]
         - [[保守性の困難化]]
      - [[限定的な `goto` 文の許容例 (エラー処理、多重ループ脱出 - 議論あり)]]
   - **[[(オプション) 例外処理 (Exception Handling) の手続き型言語における実現]]** (C言語では `setjmp`/`longjmp` など、限定的)

## 5. [[データ型と変数 (Data Types and Variables) MOC]]
   - **変数の基本**
      - [[変数とは (データを格納するメモリ上の名前付き領域)]]
      - [[変数宣言 (Variable Declaration)]] (型と名前の指定)
      - [[変数への代入 (Assignment)]]
      - [[変数の初期化 (Initialization)]]
   - **基本データ型 (Primitive / Basic Data Types)**
      - **[[整数型 (Integer Types)]]** (`int`, `short`, `long`, `byte` など、符号付き/符号なし)
      - **[[浮動小数点型 (Floating-Point Types)]]** (`float`, `double`, `real` など)
         - [[浮動小数点数の内部表現 (IEEE 754)]]
         - [[浮動小数点演算の誤差]]
      - **[[文字型 (Character Types)]]** (`char`, ASCII, Unicode)
      - **[[ブーリアン型 (Boolean Type)]]** (`bool`, `boolean`, 真偽値) (C言語では整数で代用することも)
   - **派生データ型 / 複合データ型 (Derived / Composite Data Types)**
      - **[[配列 (Array)]]**
         - [[配列の定義 (同じ型の要素の連続した集まり)]]
         - [[配列のインデックス (添字)]]
         - [[1次元配列、2次元配列、多次元配列]]
         - [[配列のメモリ配置]]
         - [[文字列としての文字配列 (C言語のヌル終端文字列)]]
      - **[[構造体 (Structure - C/C++) / レコード (Record - Pascal)]]**
         - [[構造体の定義 (異なる型のデータをまとめたもの)]]
         - [[構造体のメンバアクセス]]
         - [[構造体の配列]]
      - **[[(オプション) 共用体 (Union - C/C++)]]**
         - [[共用体の定義 (複数のメンバが同じメモリ領域を共有)]]
         - [[共用体の利用例と注意点]]
      - **[[ポインタ (Pointer - C/Pascalなど)]]**
         - [[ポインタとは (メモリアドレスを格納する変数)]]
         - [[ポインタ宣言と間接参照 (Dereferencing)]]
         - [[ポインタと配列の関係 (C言語)]]
         - [[ポインタ演算]]
         - [[NULLポインタ / `nil`]]
         - [[動的メモリ確保とポインタ]]
         - [[ポインタの危険性 (ダングリングポインタ、メモリリーク)]]
   - **型変換 (Type Conversion / Casting)**
      - [[暗黙の型変換 (Implicit Type Conversion / Coercion)]]
      - [[明示的な型変換 (Explicit Type Conversion / Type Casting)]]
   - **[[(オプション) typedef / 型エイリアス (Type Alias)]]**

## 6. [[入出力 (I/O) 操作 MOC]]
   - **標準入出力 (Standard Input/Output)**
      - [[標準入力 (stdin) と標準出力 (stdout)、標準エラー出力 (stderr)]]
      - [[コンソールからの入力 (例: `scanf`, `gets`, `cin`, `readln`)]]
      - [[コンソールへの出力 (例: `printf`, `puts`, `cout`, `writeln`)]]
      - [[リダイレクションとパイプ (OSの機能との連携)]]
   - **ファイル入出力 (File I/O)**
      - **[[ファイルとは (補助記憶装置上のデータのまとまり)]]**
      - **[[ファイルのオープン (Open)]]** (ファイル名、モード指定 - 読込/書込/追記、バイナリ/テキスト)
      - **[[ファイルポインタ / ファイルハンドル]]**
      - **[[ファイルからの読み込み (Read)]]** (文字単位、行単位、ブロック単位)
      - **[[ファイルへの書き込み (Write)]]**
      - **[[ファイルのクローズ (Close)]]**
      - **[[ファイルの位置制御 (Seek)]]** (ファイルポインタの移動)
      - [[エラー処理 (ファイルが見つからない、アクセス権限など)]]
      - [[テキストファイルとバイナリファイル]]

## 7. [[メモリ管理 (Memory Management) - 手続き型における基礎 MOC]]
   - **メモリ領域の分類**
      - [[静的領域 (Static/Global Area)]] (グローバル変数、静的変数)
      - [[スタック領域 (Stack Area)]] (ローカル変数、関数呼び出し情報)
      - [[ヒープ領域 (Heap Area)]] (動的に確保されるメモリ)
   - **静的メモリ割り当て (Static Memory Allocation)**
      - [[コンパイル時にメモリサイズが決定]]
   - **スタックベースのメモリ割り当て (Stack-based Memory Allocation)**
      - [[関数呼び出し時のスタックフレームのプッシュとポップ]]
      - [[自動的なメモリ確保と解放]]
   - **動的メモリ割り当て (Dynamic Memory Allocation)** (ヒープ領域)
      - **[[C言語における動的メモリ確保 (`malloc`, `calloc`, `realloc`, `free`)]]**
      - **[[Pascalにおける動的メモリ確保 (`New`, `Dispose`)]]**
      - [[動的メモリ確保の必要性]]
      - **[[メモリリーク (Memory Leak)]]** (`free`/`Dispose`のし忘れ)
      - **[[ダングリングポインタ (Dangling Pointer)]]** (解放済みメモリへのポインタ)
      - **[[ヒープの断片化 (Heap Fragmentation)]]**
      - **[[(オプション) ガーベジコレクション (Garbage Collection) - 手続き型言語では通常は手動管理]]**

## 8. [[手続き型プログラミングの利点と欠点 MOC]]
   - **利点**
      - [[単純明快で理解しやすい (小規模なプログラムにおいて)]]
      - [[実行効率が良い場合がある (低レベルな制御が可能)]]
      - [[多くのシステムプログラミングや組み込み分野での実績]]
      - [[習得が比較的容易 (他のパラダイムの基礎として)]]
      - [[豊富な既存コードベースとライブラリ (特にC言語)]]
   - **欠点**
      - **[[大規模開発における管理の難しさ]]**
         - [[グローバル変数の多用による副作用の増加]]
         - [[コードの再利用性が限定的 (OOPなどに比べて)]]
         - [[データと手続きの分離による凝集度の低下]]
         - [[変更時の影響範囲の特定が困難]]
      - [[現実世界のモデリングが直感的でない場合がある]]
      - [[状態管理の複雑化]]

## 9. [[手続き型プログラミングの設計手法 MOC]]
   - **[[トップダウン設計 (Top-down Design)]]**
      - [[問題を大きなタスクから小さなサブタスクへ分解していく]]
   - **[[ステップワイズリファインメント (Stepwise Refinement)]]**
      - [[段階的に詳細化していく設計プロセス]]
   - **[[構造化チャート / フローチャート]]** (設計の視覚化)
   - **[[(関連) モジュール設計の原則 (凝集度を高め、結合度を低くする)]]**

## 10. [[代表的な手続き型言語の特徴と例 MOC]]
   - **[[C言語における手続き型プログラミング]]** (ポインタ、メモリ管理、システムコール)
   - **[[Pascalにおける手続き型プログラミング]]** (構造化、型安全性、教育用)
   - **[[FORTRANにおける手続き型プログラミング]]** (数値計算、サブルーチン)
   - **[[COBOLにおける手続き型プログラミング]]** (データ構造、事務処理)
   - **[[BASIC (初期) における手続き型プログラミング]]** (GOTO、行番号)
   - **[[(現代) 手続き型スタイルが活用される場面]]** (スクリプト、小さなユーティリティ、パフォーマンスが重要な部分)