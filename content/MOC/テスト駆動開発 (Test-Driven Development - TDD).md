---
tags:
  - moc
enableToc: "true"
draft: "false"
permalink: moc/tdd
---
## 1. [[テスト駆動アプローチ入門 MOC]]
   - **ソフトウェア開発におけるテストの役割の変化**
      - [[伝統的な開発プロセスにおけるテストの位置づけ (テストアフター)]]
      - [[テストファーストアプローチの台頭]]
   - **アジャイル開発とテスト駆動アプローチ**
      - [[アジャイルマニフェストとテストの関連性]]
      - [[継続的インテグレーション (CI) / 継続的デリバリー (CD) とテスト駆動]]
   - **TDDとBDDの概要と比較の導入**
      - [[TDDとBDDの共通点 (テストファースト、反復的開発)]]
      - [[TDDとBDDの焦点の違い (ユニットレベル vs. ビヘイビア/フィーチャーレベル)]]

## 2. [[テスト駆動開発 (Test-Driven Development - TDD) MOC]]

### 2.1. [[TDDの基本原則と哲学 MOC]]
   - **TDDとは何か**
      - [[TDDの定義 (テストを先に書き、そのテストをパスする最小限のコードを実装し、リファクタリングする開発サイクル)]]
      - [[ケント・ベックによるTDDの提唱]]
   - **TDDの目的**
      - [[高品質なコードの生成]]
      - [[設計の改善 (疎結合、高凝集)]]
      - [[リファクタリングの安全性確保]]
      - [[ドキュメントとしてのテストコード]]
      - [[開発者の自信向上と開発リズムの確立]]
   - **TDDの3つの法則 (Three Laws of TDD)**
      - `[[1. テストが失敗するまでは、プロダクションコードを書いてはならない。]]`
      - `[[2. 失敗するテストは、一度に1つだけ書く。コンパイルエラーも失敗とみなす。]]`
      - `[[3. 失敗したテストが通るようになったら、それ以上プロダクションコードを書いてはならない。]]`

### 2.2. [[TDDのサイクル (Red-Green-Refactor) MOC]]
   - **[[レッド (Red) フェーズ: 失敗するテストを書く]]**
      - [[何をテストするか決定する (要求の明確化)]]
      - [[テストのインターフェースを設計する]]
      - [[期待される結果を定義する]]
      - [[テストが「正しく失敗する」ことの確認]] (存在しないクラス/メソッド、間違ったロジックなど)
   - **[[グリーン (Green) フェーズ: テストをパスさせる]]**
      - [[テストをパスさせるための最小限のプロダクションコードを実装する]]
      - [[「仮実装 (Fake It Till You Make It)」戦略]]
      - [[この段階ではコードの綺麗さは二の次]]
   - **[[リファクタリング (Refactor) フェーズ: コードを改善する]]**
      - [[テストが通る状態を維持しながら、プロダクションコードとテストコードの両方を改善する]]
      - [[重複の排除 (DRY原則)]]
      - [[可読性の向上]]
      - [[設計の改善 (SOLID原則など)]]
      - [[リファクタリングのタイミングと範囲]]
   - **TDDサイクルの継続とリズム**

### 2.3. [[TDDにおけるテストの種類とレベル MOC]]
   - **[[ユニットテスト (Unit Test) とTDD]]** (TDDの主な焦点)
      - [[ユニットの定義 (クラス、メソッド、関数)]]
      - [[良いユニットテストの特性 (FIRST: Fast, Independent/Isolated, Repeatable, Self-Validating, Timely/Thorough)]]
      - `[[テストダブル (Test Double) の利用 MOC]]`
         - `[[スタブ (Stub)]]`
         - `[[モック (Mock)]]` (状態検証 vs. 振る舞い検証)
         - `[[フェイク (Fake)]]`
         - `[[ダミー (Dummy)]]`
         - `[[スパイ (Spy)]]`
         - `[[モックライブラリの利用 (Mockito, Moq, unittest.mockなど)]]`
   - **[[(オプション) 受入テスト駆動開発 (ATDD - Acceptance Test-Driven Development) とTDD]]** (BDDとの関連)
   - **[[(オプション) インテグレーションテストとTDD]]** (適用範囲と注意点)

### 2.4. [[TDDのプラクティスとテクニック MOC]]
   - **[[テストファースト (Test First)]]** (原則の再確認)
   - **[[インクリメンタルな設計 (Incremental Design)]]**
   - **[[緊急回避的な仮実装 (Triangulation)]]** (複数のテストケースから一般化)
   - **[[テストリストの作成と管理]]**
   - **[[明白な実装 (Obvious Implementation)]]**
   - **[[設計上の決定を遅らせる]]**
   - **[[テストしやすいコードを書くための設計]]** (依存性の注入など)
   - **[[TDDにおけるテストカバレッジの考え方]]** (目標としての100%とその意味)
   - **[[レガシーコードとTDD]]**
      - [[特性化テスト (Characterization Tests / Golden Master Tests)]]
      - [[レガシーコードのリファクタリング戦略]]

### 2.5. [[TDDの利点と課題 MOC]]
   - **TDDの利点**
      - [[バグの早期発見と削減]]
      - [[設計品質の向上 (疎結合、高凝集、テスト容易性)]]
      - [[リファクタリングの心理的安全性]]
      - [[実行可能なドキュメントとしてのテストコード]]
      - [[開発サイクルの短縮 (手戻りの削減)]]
      - [[開発者の自信と生産性の向上]]
   - **TDDの課題と欠点**
      - [[学習曲線と習熟の難しさ]]
      - [[初期の開発速度の低下感]]
      - [[テストコードの記述・保守コスト]]
      - [[テストが困難なケース (GUI, 非同期処理, 外部システム連携など) とその対策]]
      - [[「何をテストすべきか」の判断の難しさ]]
      - [[テストの質への依存 (質の低いテストは効果が薄い)]]
      - [[過度なモックの使用による弊害]]

### 2.6. [[TDDとソフトウェア設計 MOC]]
   - [[TDDが設計に与える影響]]
   - [[テスト容易性 (Testability) を考慮した設計]]
      - `[[依存性の注入 (Dependency Injection - DI)]]`
      - `[[インターフェースの活用]]`
      - `[[関心の分離 (SoC)]]`
   - **[[TDDとSOLID原則]]**
      - [[SRPとTDD (テストしやすい小さなクラス)]]
      - [[OCPとTDD (既存テストを壊さずに拡張)]]
      - [[LSPとTDD (サブタイプの振る舞いのテスト)]]
      - [[ISPとTDD (特定のインターフェースへのテスト)]]
      - [[DIPとTDD (抽象への依存によるモックの容易さ)]]
   - **[[TDDによる設計の創発 (Emergent Design)]]**
   - **[[TDDとアーキテクチャ]]**

### 2.7. [[TDDアンチパターン MOC]]
   - `[[テストアフター (TDDサイクルの無視)]]`
   - `[[大きすぎるテスト (ユニットテストになっていない)]]`
   - `[[テストがプロダクションコードの実装詳細に依存しすぎる (脆いテスト)]]`
   - `[[網羅性の低いテスト / ハッピーパスのみのテスト]]`
   - `[[リファクタリングフェーズの省略]]`
   - `[[テストコードの品質軽視]]`
   - `[[テストが遅すぎる]]`
   - `[[モックの乱用 / 過剰なモック設定]]`
   - `[[アサーションが少なすぎる / 多すぎる]]`
   - `[[テストが互いに依存している]]`

### 2.8. [[TDDツールとフレームワーク MOC]]
   - **xUnitファミリー**
      - `[[JUnit (Java)]]`
      - `[[NUnit (.NET)]]`
      - `[[pytest / unittest (Python)]]`
      - `[[PHPUnit (PHP)]]`
      - `[[RSpec (Ruby - BDD寄りだがユニットテストにも)]]`
      - `[[Jest / Mocha (JavaScript)]]`
      - `[[Google Test (C++)]]`
   - **モックライブラリ** (再掲)
   - **テストカバレッジツール** (JaCoCo, Coverage.py, Istanbulなど)
   - **IDEとの統合**

## 3. [[ビヘイビア駆動開発 (Behavior-Driven Development - BDD) MOC]]

### 3.1. [[BDDの基本原則と哲学 MOC]]
   - **BDDとは何か**
      - [[BDDの定義 (ビジネス要件と技術的実装を結びつける、共通言語を用いたコミュニケーション重視の開発アプローチ)]]
      - [[TDDの進化形、または特定のアプローチとしてのBDD (Dan Northによる提唱)]]
      - [[「外側から内側へ (Outside-In Development)」のアプローチ]]
   - **BDDの目的**
      - [[チーム内 (開発者、QA、PO/ビジネスアナリスト) の共通理解の促進]]
      - [[ビジネス価値のあるソフトウェアの提供]]
      - [[振る舞い (Behavior) を中心とした仕様記述とテスト]]
      - [[生きたドキュメント (Living Documentation) の作成]]
      - [[誤解や手戻りの削減]]
   - **BDDの核となる考え方**
      - [[コラボレーション (Three Amigos: Business, Development, Testing)]]
      - [[ユビキタス言語の活用 (DDDとの関連)]]
      - [[振る舞いの明示化]]

### 3.2. [[BDDのサイクルとプロセス MOC]]
   - **ディスカバリー (Discovery / Specification Workshop)**
      - [[ユーザーストーリーやフィーチャーの明確化]]
      - [[具体例を用いた会話 (Example Mapping, Feature Mapping)]]
      - [[受け入れ基準 (Acceptance Criteria) の共同定義]]
   - **フォーミュレーション (Formulation)**
      - [[受け入れ基準を構造化された自然言語 (例: Gherkin) で記述]]
      - [[シナリオの作成]]
   - **オートメーション (Automation)**
      - [[記述されたシナリオを自動化テストとして実装]]
      - [[テストコードとステップ定義 (Step Definitions) の作成]]
      - [[TDDサイクルを内部で回すことも]]
   - **BDDループ (フィーチャーの実現と検証)**

### 3.3. [[BDDにおける主要な概念とテクニック MOC]]
   - **[[ユーザーストーリー (User Story)]]** (`As a <role>, I want <feature> so that <benefit>`)
   - **[[フィーチャー (Feature)]]** (振る舞いの単位)
   - **[[シナリオ (Scenario)]]** (フィーチャーの具体的な例)
      - [[シナリオの構成 (コンテキスト、イベント、結果)]]
   - **[[Gherkin言語 MOC]]** (Cucumberなどで使われる記述言語)
      - `[[Feature`キーワード]]
      - `[[Scenario`キーワード]]
      - `[[Given` (前提条件 / コンテキスト)]]
      - `[[When` (操作 / イベント)]]
      - `[[Then` (期待される結果 / 検証)]]
      - `[[And`, `But` (ステップの追加)]]
      - `[[Background` (共通の前提条件)]]
      - `[[Scenario Outline` と `Examples` (データ駆動シナリオ)]]
      - `[[Tags` (シナリオの分類とフィルタリング)]]
      - `[[Doc Strings` と `Data Tables` (ステップへの詳細データ提供)]]
   - **[[ステップ定義 (Step Definitions)]]**
      - [[Gherkinの各ステップと実際のテストコードを結びつけるグルーコード]]
      - [[正規表現やパラメータ化によるステップの再利用]]
   - **[[生きたドキュメント (Living Documentation)]]**
      - [[テスト結果と連動し、常に最新状態が保たれるドキュメント]]
   - **[[Outside-In Development (外側からの開発)]]**
      - [[UI/APIレベルのテストから始め、内部のユニットをTDDで実装していく流れ]]
   - **[[Example Mapping]]** (ディスカバリーのためのテクニック)
   - **[[Feature Mapping]]** (ディスカバリーのためのテクニック)

### 3.4. [[BDDの利点と課題 MOC]]
   - **BDDの利点**
      - [[ビジネス要件と開発の整合性向上]]
      - [[チーム全体のコミュニケーションとコラボレーション促進]]
      - [[仕様の明確化と誤解の防止]]
      - [[高品質な受け入れテストの自動化]]
      - [[生きたドキュメントによる保守性向上]]
      - [[ユーザー中心の開発]]
   - **BDDの課題と欠点**
      - [[導入と定着のための初期コストと努力]]
      - [[Gherkin記述のスキルとメンテナンス]] (冗長になる、技術的詳細が混じるなど)
      - [[適切な粒度でのフィーチャーやシナリオの定義の難しさ]]
      - [[テスト実行時間の増加 (UIテストなどが多用される場合)]]
      - [[ツールへの依存度]]
      - [[「テスト」という言葉を避けることによる誤解の可能性]]

### 3.5. [[BDDツールとフレームワーク MOC]]
   - **[[Cucumberファミリー]]** (Gherkinパーサー + テスト実行)
      - `[[Cucumber (Ruby)]]`
      - `[[Cucumber-JVM (Java)]]`
      - `[[Cucumber.js (JavaScript)]]`
      - `[[SpecFlow (.NET)]]`
      - `[[Behave (Python)]]`
   - **[[RSpec (Ruby)]]** (BDDスタイルのテストフレームワーク)
   - **[[JBehave (Java)]]**
   - **[[Gauge (ThoughtWorks)]]** (Markdownベースの仕様記述)
   - **[[Serenity BDD (旧Thucydides)]]** (Java, よりリッチなレポート)
   - **Webテスト自動化ツールとの連携** (Selenium, Playwright, Cypressなど)

## 4. [[TDDとBDDの比較と関係 MOC]]
   - **[[焦点の違い (TDD: ユニットの正しい実装 vs. BDD: システムの正しい振る舞い)]]**
   - **[[対象読者の違い (TDD: 開発者 vs. BDD: チーム全体 - ビジネス含む)]]**
   - **[[使用する言語の違い (TDD: プログラミング言語 vs. BDD: 自然言語に近いGherkinなど)]]**
   - **[[テストの粒度の違い (TDD: 小さいユニット vs. BDD: より大きなフィーチャー/シナリオ)]]**
   - **[[「TDDはBDDのサブセット」か「BDDはTDDの拡張」か]]**
      - [[BDDのシナリオ自動化の内部でTDDサイクルを回す考え方 (Double Loop)]]
   - **[[TDDとBDDの補完関係]]**
   - **[[どちらをいつ使うべきか (プロジェクトの特性、チームのスキル)]]**
      - [[ライブラリ開発や低レベルコンポーネントにはTDDが適している場合が多い]]
      - [[ユーザーストーリーやビジネスロジックが明確なフィーチャーにはBDDが有効]]

## 5. [[テスト駆動アプローチの組織への導入と展開 MOC]]
   - **導入のステップと戦略**
      - [[パイロットプロジェクトの実施]]
      - [[段階的な導入]]
      - [[成功体験の共有]]
   - **チームへの教育とトレーニング**
      - [[ペアプログラミングやモブプログラミングによる実践学習]]
      - [[外部コーチやコンサルタントの活用]]
   - **文化醸成とマインドセットの変革**
      - [[テストを「コスト」ではなく「投資」と捉える]]
      - [[品質への共同責任]]
      - [[失敗を許容し、学びを促進する環境]]
   - **経営層やマネジメントの理解と支援**
   - **ツール選定と環境構築**
   - **導入時の一般的な障壁と対策**
      - [[時間的プレッシャー]]
      - [[既存のコードベースへの適用]]
      - [[スキル不足と学習意欲]]
      - [[効果測定の難しさ]]
   - **テスト駆動アプローチの成熟度モデル (例)**
